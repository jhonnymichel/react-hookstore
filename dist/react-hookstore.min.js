!function(t){var e={};function n(s){if(e[s])return e[s].exports;var r=e[s]={i:s,l:!1,exports:{}};return t[s].call(r.exports,r,r.exports,n),r.l=!0,r.exports}n.m=t,n.c=e,n.d=function(t,e,s){n.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:s})},n.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n.t=function(t,e){if(1&e&&(t=n(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var s=Object.create(null);if(n.r(s),Object.defineProperty(s,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var r in t)n.d(s,r,function(e){return t[e]}.bind(null,r));return s},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,"a",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p="",n(n.s=1)}([function(t,e){t.exports=void 0},function(t,e,n){"use strict";n.r(e),n.d(e,"createStore",function(){return c}),n.d(e,"getStoreByName",function(){return f}),n.d(e,"useStore",function(){return d});var s=n(0);let r={},o={};const i=(t,e)=>e,a=t=>t;class u{constructor(t,e,n){this.name=t,n?this.dispatch=e.setState:this.setState=e.setState,this.getState=(()=>e.state),this.subscribe=this.subscribe.bind(this)}subscribe(t){if(!t||"function"!=typeof t)throw`store.subscribe callback argument must be a function. got '${typeof t}' instead.`;if(!o[this.name].find(e=>e===t))return o[this.name].push(t),()=>{o[this.name]=o[this.name].filter(e=>e!==t)};console.warn("This callback is already subscribed to this store. skipping subscription")}setState(t){console.warn(`[React Hookstore] Store ${this.name} uses a reducer to handle its state updates. use dispatch instead of setState`)}dispatch(t){console.warn(`[React Hookstore] Store ${this.name} does not use a reducer to handle state updates. use setState instead of dispatch`)}}function c(t,e={},n=i){if("string"!=typeof t)throw"Store name must be a string";if(r[t])throw`Store with name ${t} already exists`;const s={state:e,reducer:n,setState(e,n){if(this.reducer===i&&e===this.state&&"object"!=typeof e)return void("function"==typeof n&&n(this.state));const s=this.state,r=this.reducer(this.state,e);this.state=r,this.updatersPerMemoFunction.forEach((t,e)=>{if(e(s)!==e(r))for(let e of t)e(this.state)}),o[t].length&&o[t].forEach(t=>t(this.state,e)),"function"==typeof n&&n(this.state)},updatersPerMemoFunction:new Map};return s.setState=s.setState.bind(s),s.updatersPerMemoFunction.set(a,new Set),r=Object.assign({},r,{[t]:s}),o[t]=[],s.public=new u(t,s,n!==i),s.public}function f(t){try{return r[t].public}catch(e){throw`Store with name ${t} does not exist`}}function d(t,e=a){const n=function(t){const e=t instanceof u?t.name:t;if(!r[e])throw`Store with name ${e} does not exist`;return r[e]}(t);if(!n)throw"store does not exist";if("function"!=typeof e)throw"memoFn must be a function";const[o,i]=Object(s.useState)(n.state);return Object(s.useEffect)(()=>{n.updatersPerMemoFunction.has(e)||n.updatersPerMemoFunction.set(e,new Set);const t=n.updatersPerMemoFunction.get(e);return t.has(i)||t.add(i),()=>{t.delete(i),t.size||n.updatersPerMemoFunction.delete(e)}},[]),[o,n.setState]}}]);